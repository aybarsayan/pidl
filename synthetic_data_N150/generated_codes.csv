code_id,session_id,code_text,language,prompt_used,ai_persona,generation_time_seconds
1,1,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Deniz - DApp Architect,99
2,2,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(_proposalId < proposals.length, ""Invalid proposal"");
        require(!hasVoted[msg.sender], ""Already voted"");
        require(!proposals[_proposalId].executed, ""Proposal executed"");

        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;

        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Elif - Security Aware,114
3,3,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter || msg.sender == buyer, ""Unauthorized"");
        require(!released, ""Already released"");
        require(amount > 0, ""No funds"");

        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Elif - Security Aware,57
4,4,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(_to != address(0), ""Invalid address"");
        require(_value > 0, ""Amount must be positive"");
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Elif - Security Aware,117
5,5,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Deniz - DApp Architect,40
6,6,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Deniz - DApp Architect,34
7,7,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,66
8,8,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,35
9,9,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,86
10,10,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,86
11,11,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,115
12,12,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,70
13,13,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,111
14,14,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,47
15,15,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,89
16,16,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Prof. Mehmet - Academic,53
17,17,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,119
18,18,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,83
19,19,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Deniz - DApp Architect,81
20,20,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,52
21,21,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,61
22,22,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Deniz - DApp Architect,66
23,23,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Deniz - DApp Architect,33
24,24,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,62
25,25,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Can - Gas Optimizer,64
26,26,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,86
27,27,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Can - Gas Optimizer,35
28,28,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,111
29,29,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Can - Gas Optimizer,110
30,30,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,101
31,31,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,117
32,32,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,114
33,33,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,86
34,34,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Prof. Mehmet - Academic,70
35,35,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,74
36,36,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,36
37,37,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,67
38,38,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,52
39,39,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,87
40,40,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Prof. Mehmet - Academic,49
41,41,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,54
42,42,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,66
43,43,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,84
44,44,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,94
45,45,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,95
46,46,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Deniz - DApp Architect,71
47,47,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Deniz - DApp Architect,34
48,48,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Deniz - DApp Architect,41
49,49,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Dr. Ayşe - Beginner Friendly,74
50,50,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Öğretmen Zeynep - Practical,99
51,51,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Dr. Ayşe - Beginner Friendly,48
52,52,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Dr. Ayşe - Beginner Friendly,47
53,53,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Öğretmen Zeynep - Practical,90
54,54,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,97
55,55,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,66
56,56,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,82
57,57,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,93
58,58,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,103
59,59,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,87
60,60,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,119
61,61,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,59
62,62,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,119
63,63,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,39
64,64,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,102
65,65,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,30
66,66,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,109
67,67,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,47
68,68,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,49
69,69,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,51
70,70,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Prof. Mehmet - Academic,107
71,71,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,114
72,72,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,95
73,73,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,105
74,74,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,40
75,75,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,92
76,76,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,57
77,77,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,42
78,78,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,41
79,79,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Deniz - DApp Architect,57
80,80,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,57
81,81,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,79
82,82,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,98
83,83,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Deniz - DApp Architect,63
84,84,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Deniz - DApp Architect,76
85,85,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Deniz - DApp Architect,69
86,86,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(_proposalId < proposals.length, ""Invalid proposal"");
        require(!hasVoted[msg.sender], ""Already voted"");
        require(!proposals[_proposalId].executed, ""Proposal executed"");

        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;

        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Elif - Security Aware,71
87,87,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter || msg.sender == buyer, ""Unauthorized"");
        require(!released, ""Already released"");
        require(amount > 0, ""No funds"");

        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Elif - Security Aware,80
88,88,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(_to != address(0), ""Invalid address"");
        require(_value > 0, ""Amount must be positive"");
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Elif - Security Aware,45
89,89,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Deniz - DApp Architect,61
90,90,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Deniz - DApp Architect,52
91,91,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Mentor Fatma - Supportive,75
92,92,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,72
93,93,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,78
94,94,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,41
95,95,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Mentor Fatma - Supportive,49
96,96,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Mentor Fatma - Supportive,55
97,97,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Mentor Fatma - Supportive,68
98,98,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Mentor Fatma - Supportive,77
99,99,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Öğretmen Zeynep - Practical,46
100,100,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,113
101,101,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Öğretmen Zeynep - Practical,42
102,102,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Mentor Fatma - Supportive,73
103,103,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,75
104,104,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,90
105,105,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,91
106,106,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Prof. Mehmet - Academic,86
107,107,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,35
108,108,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,36
109,109,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,119
110,110,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,104
111,111,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,117
112,112,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,99
113,113,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,117
114,114,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,94
115,115,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,112
116,116,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,75
117,117,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,40
118,118,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,42
119,119,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,40
120,120,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,117
121,121,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Can - Gas Optimizer,49
122,122,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,106
123,123,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Can - Gas Optimizer,106
124,124,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Can - Gas Optimizer,30
125,125,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,103
126,126,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,106
127,127,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,103
128,128,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,75
129,129,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,65
130,130,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,93
131,131,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,36
132,132,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,87
133,133,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Dr. Ayşe - Beginner Friendly,61
134,134,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Öğretmen Zeynep - Practical,76
135,135,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Dr. Ayşe - Beginner Friendly,60
136,136,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,57
137,137,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Öğretmen Zeynep - Practical,50
138,138,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Dr. Ayşe - Beginner Friendly,49
139,139,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Mentor Fatma - Supportive,42
140,140,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Öğretmen Zeynep - Practical,97
141,141,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Mentor Fatma - Supportive,50
142,142,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,95
143,143,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Öğretmen Zeynep - Practical,83
144,144,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Mentor Fatma - Supportive,100
145,145,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Mentor Fatma - Supportive,57
146,146,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Mentor Fatma - Supportive,120
147,147,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Öğretmen Zeynep - Practical,47
148,148,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,45
149,149,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Mentor Fatma - Supportive,92
150,150,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,61
151,151,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,72
152,152,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,106
153,153,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,41
154,154,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Deniz - DApp Architect,109
155,155,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Deniz - DApp Architect,30
156,156,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,38
157,157,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,35
158,158,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,39
159,159,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,89
160,160,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,82
161,161,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,112
162,162,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,30
163,163,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,94
164,164,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,108
165,165,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,65
166,166,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Prof. Mehmet - Academic,90
167,167,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,116
168,168,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,44
169,169,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Dr. Ayşe - Beginner Friendly,81
170,170,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Dr. Ayşe - Beginner Friendly,75
171,171,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Öğretmen Zeynep - Practical,59
172,172,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,45
173,173,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Dr. Ayşe - Beginner Friendly,56
174,174,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,117
175,175,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Dr. Ayşe - Beginner Friendly,64
176,176,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Dr. Ayşe - Beginner Friendly,61
177,177,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Dr. Ayşe - Beginner Friendly,120
178,178,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,109
179,179,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Öğretmen Zeynep - Practical,38
180,180,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,82
181,181,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Mentor Fatma - Supportive,72
182,182,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Öğretmen Zeynep - Practical,116
183,183,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Mentor Fatma - Supportive,56
184,184,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Mentor Fatma - Supportive,111
185,185,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Öğretmen Zeynep - Practical,118
186,186,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,77
187,187,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,68
188,188,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,90
189,189,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,67
190,190,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,112
191,191,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,92
192,192,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,80
193,193,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Dr. Ayşe - Beginner Friendly,116
194,194,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Dr. Ayşe - Beginner Friendly,68
195,195,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Dr. Ayşe - Beginner Friendly,117
196,196,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,112
197,197,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Öğretmen Zeynep - Practical,48
198,198,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,45
199,199,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Deniz - DApp Architect,63
200,200,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(_proposalId < proposals.length, ""Invalid proposal"");
        require(!hasVoted[msg.sender], ""Already voted"");
        require(!proposals[_proposalId].executed, ""Proposal executed"");

        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;

        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Elif - Security Aware,93
201,201,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Deniz - DApp Architect,80
202,202,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(_to != address(0), ""Invalid address"");
        require(_value > 0, ""Amount must be positive"");
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Elif - Security Aware,41
203,203,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        require(stakedBalance[msg.sender] > 0, ""No stake"");

        uint256 timeStaked = block.timestamp - stakingTime[msg.sender];
        uint256 reward = (stakedBalance[msg.sender] * rewardRate * timeStaked) / (365 days * 100);

        uint256 total = stakedBalance[msg.sender] + reward;
        stakedBalance[msg.sender] = 0;

        payable(msg.sender).transfer(total);
        emit Unstaked(msg.sender, total);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Elif - Security Aware,63
204,204,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Deniz - DApp Architect,42
205,205,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,46
206,206,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,40
207,207,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,80
208,208,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Prof. Mehmet - Academic,118
209,209,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,67
210,210,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,93
211,211,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Mentor Fatma - Supportive,59
212,212,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Mentor Fatma - Supportive,42
213,213,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Öğretmen Zeynep - Practical,96
214,214,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,109
215,215,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Öğretmen Zeynep - Practical,45
216,216,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Mentor Fatma - Supportive,90
217,217,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,92
218,218,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,86
219,219,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Can - Gas Optimizer,35
220,220,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,71
221,221,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Can - Gas Optimizer,48
222,222,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Can - Gas Optimizer,101
223,223,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Öğretmen Zeynep - Practical,65
224,224,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Öğretmen Zeynep - Practical,63
225,225,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Dr. Ayşe - Beginner Friendly,118
226,226,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Dr. Ayşe - Beginner Friendly,78
227,227,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Dr. Ayşe - Beginner Friendly,43
228,228,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,96
229,229,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid address"");
        require(_value > 0, ""Amount must be positive"");
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Elif - Security Aware,33
230,230,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,54
231,231,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Deniz - DApp Architect,77
232,232,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(_to != address(0), ""Invalid address"");
        require(_value > 0, ""Amount must be positive"");
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Elif - Security Aware,77
233,233,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        require(stakedBalance[msg.sender] > 0, ""No stake"");

        uint256 timeStaked = block.timestamp - stakingTime[msg.sender];
        uint256 reward = (stakedBalance[msg.sender] * rewardRate * timeStaked) / (365 days * 100);

        uint256 total = stakedBalance[msg.sender] + reward;
        stakedBalance[msg.sender] = 0;

        payable(msg.sender).transfer(total);
        emit Unstaked(msg.sender, total);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Elif - Security Aware,99
234,234,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Deniz - DApp Architect,77
235,235,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,37
236,236,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,61
237,237,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,57
238,238,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Prof. Mehmet - Academic,114
239,239,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,106
240,240,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,57
241,241,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,77
242,242,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,78
243,243,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,91
244,244,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,54
245,245,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,61
246,246,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,69
247,247,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Can - Gas Optimizer,116
248,248,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,81
249,249,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Can - Gas Optimizer,67
250,250,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Can - Gas Optimizer,90
251,251,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,30
252,252,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,45
253,253,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,48
254,254,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,113
255,255,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Mentor Fatma - Supportive,97
256,256,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Mentor Fatma - Supportive,35
257,257,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,62
258,258,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Mentor Fatma - Supportive,72
259,259,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid address"");
        require(_value > 0, ""Amount must be positive"");
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Elif - Security Aware,41
260,260,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,30
261,261,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter || msg.sender == buyer, ""Unauthorized"");
        require(!released, ""Already released"");
        require(amount > 0, ""No funds"");

        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Elif - Security Aware,80
262,262,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Deniz - DApp Architect,76
263,263,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        require(stakedBalance[msg.sender] > 0, ""No stake"");

        uint256 timeStaked = block.timestamp - stakingTime[msg.sender];
        uint256 reward = (stakedBalance[msg.sender] * rewardRate * timeStaked) / (365 days * 100);

        uint256 total = stakedBalance[msg.sender] + reward;
        stakedBalance[msg.sender] = 0;

        payable(msg.sender).transfer(total);
        emit Unstaked(msg.sender, total);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Elif - Security Aware,94
264,264,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Deniz - DApp Architect,43
265,265,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,115
266,266,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,46
267,267,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,81
268,268,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Prof. Mehmet - Academic,110
269,269,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,104
270,270,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,97
271,271,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Öğretmen Zeynep - Practical,79
272,272,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Dr. Ayşe - Beginner Friendly,113
273,273,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Öğretmen Zeynep - Practical,59
274,274,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Dr. Ayşe - Beginner Friendly,33
275,275,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Dr. Ayşe - Beginner Friendly,34
276,276,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,78
277,277,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,67
278,278,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,102
279,279,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,117
280,280,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,40
281,281,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,111
282,282,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,48
283,283,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,50
284,284,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,89
285,285,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,103
286,286,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,46
287,287,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,82
288,288,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,57
289,289,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,97
290,290,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,107
291,291,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,73
292,292,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,77
293,293,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,40
294,294,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,55
295,295,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid address"");
        require(_value > 0, ""Amount must be positive"");
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Elif - Security Aware,60
296,296,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,38
297,297,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Deniz - DApp Architect,74
298,298,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(_to != address(0), ""Invalid address"");
        require(_value > 0, ""Amount must be positive"");
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Elif - Security Aware,43
299,299,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Deniz - DApp Architect,101
300,300,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(block.timestamp < endTime, ""Auction ended"");
        require(msg.value > highestBid, ""Bid too low"");
        require(!ended, ""Auction finalized"");

        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}

        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Elif - Security Aware,90
301,301,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,36
302,302,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,110
303,303,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,48
304,304,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,88
305,305,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,63
306,306,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,52
307,307,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Deniz - DApp Architect,67
308,308,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,114
309,309,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Deniz - DApp Architect,91
310,310,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Deniz - DApp Architect,74
311,311,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,40
312,312,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,114
313,313,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,52
314,314,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,117
315,315,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,76
316,316,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,107
317,317,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,115
318,318,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,101
319,319,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,70
320,320,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,86
321,321,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Deniz - DApp Architect,111
322,322,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,53
323,323,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Deniz - DApp Architect,94
324,324,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Deniz - DApp Architect,72
325,325,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,95
326,326,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,102
327,327,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,99
328,328,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,31
329,329,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,69
330,330,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,65
331,331,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Can - Gas Optimizer,101
332,332,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,112
333,333,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,113
334,334,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Can - Gas Optimizer,41
335,335,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,64
336,336,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Can - Gas Optimizer,89
337,337,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,95
338,338,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,77
339,339,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,76
340,340,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,42
341,341,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,63
342,342,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,75
343,343,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Deniz - DApp Architect,118
344,344,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,83
345,345,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter || msg.sender == buyer, ""Unauthorized"");
        require(!released, ""Already released"");
        require(amount > 0, ""No funds"");

        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Elif - Security Aware,49
346,346,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(_to != address(0), ""Invalid address"");
        require(_value > 0, ""Amount must be positive"");
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Elif - Security Aware,117
347,347,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        require(stakedBalance[msg.sender] > 0, ""No stake"");

        uint256 timeStaked = block.timestamp - stakingTime[msg.sender];
        uint256 reward = (stakedBalance[msg.sender] * rewardRate * timeStaked) / (365 days * 100);

        uint256 total = stakedBalance[msg.sender] + reward;
        stakedBalance[msg.sender] = 0;

        payable(msg.sender).transfer(total);
        emit Unstaked(msg.sender, total);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Elif - Security Aware,103
348,348,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Deniz - DApp Architect,60
349,349,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,73
350,350,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,111
351,351,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,49
352,352,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Prof. Mehmet - Academic,59
353,353,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,92
354,354,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,30
355,355,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,83
356,356,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,105
357,357,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,114
358,358,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,71
359,359,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,32
360,360,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,70
361,361,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,119
362,362,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,76
363,363,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,47
364,364,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,120
365,365,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,57
366,366,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,100
367,367,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,37
368,368,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,43
369,369,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,43
370,370,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,42
371,371,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,87
372,372,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,74
373,373,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,86
374,374,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,74
375,375,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,116
376,376,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Prof. Mehmet - Academic,117
377,377,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,97
378,378,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,53
379,379,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Dr. Ayşe - Beginner Friendly,117
380,380,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Dr. Ayşe - Beginner Friendly,103
381,381,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Dr. Ayşe - Beginner Friendly,92
382,382,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,93
383,383,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Öğretmen Zeynep - Practical,55
384,384,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,43
385,385,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,87
386,386,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,57
387,387,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,31
388,388,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,114
389,389,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,71
390,390,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,46
391,391,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,55
392,392,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Mentor Fatma - Supportive,55
393,393,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Mentor Fatma - Supportive,109
394,394,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,89
395,395,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Mentor Fatma - Supportive,93
396,396,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,102
397,397,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,64
398,398,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,50
399,399,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,102
400,400,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Deniz - DApp Architect,60
401,401,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Deniz - DApp Architect,119
402,402,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,56
403,403,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Deniz - DApp Architect,54
404,404,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,118
405,405,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Deniz - DApp Architect,36
406,406,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,72
407,407,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,100
408,408,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Deniz - DApp Architect,45
409,409,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Öğretmen Zeynep - Practical,117
410,410,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Dr. Ayşe - Beginner Friendly,113
411,411,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Öğretmen Zeynep - Practical,38
412,412,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,44
413,413,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Dr. Ayşe - Beginner Friendly,37
414,414,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Dr. Ayşe - Beginner Friendly,113
415,415,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Deniz - DApp Architect,45
416,416,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,102
417,417,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,85
418,418,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,65
419,419,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,39
420,420,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Deniz - DApp Architect,59
421,421,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Dr. Ayşe - Beginner Friendly,45
422,422,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Öğretmen Zeynep - Practical,50
423,423,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Öğretmen Zeynep - Practical,32
424,424,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Dr. Ayşe - Beginner Friendly,67
425,425,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Dr. Ayşe - Beginner Friendly,86
426,426,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,38
427,427,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,72
428,428,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,78
429,429,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,80
430,430,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,56
431,431,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,62
432,432,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,77
433,433,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Deniz - DApp Architect,58
434,434,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,112
435,435,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,89
436,436,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Deniz - DApp Architect,91
437,437,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,100
438,438,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Deniz - DApp Architect,97
439,439,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,43
440,440,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,83
441,441,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,31
442,442,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,88
443,443,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,95
444,444,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,30
445,445,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Öğretmen Zeynep - Practical,65
446,446,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Dr. Ayşe - Beginner Friendly,42
447,447,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Dr. Ayşe - Beginner Friendly,77
448,448,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,81
449,449,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Dr. Ayşe - Beginner Friendly,52
450,450,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,86
451,451,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Öğretmen Zeynep - Practical,49
452,452,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Mentor Fatma - Supportive,45
453,453,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Mentor Fatma - Supportive,69
454,454,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,54
455,455,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Mentor Fatma - Supportive,54
456,456,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,108
457,457,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,57
458,458,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,54
459,459,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,97
460,460,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Deniz - DApp Architect,66
461,461,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,109
462,462,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Deniz - DApp Architect,114
463,463,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,51
464,464,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,52
465,465,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Deniz - DApp Architect,110
466,466,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,107
467,467,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,60
468,468,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Deniz - DApp Architect,86
469,469,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,47
470,470,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Can - Gas Optimizer,95
471,471,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,99
472,472,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Can - Gas Optimizer,116
473,473,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,117
474,474,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Can - Gas Optimizer,92
475,475,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Mentor Fatma - Supportive,88
476,476,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,115
477,477,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Mentor Fatma - Supportive,70
478,478,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Mentor Fatma - Supportive,30
479,479,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,100
480,480,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,43
481,481,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,32
482,482,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,47
483,483,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,44
484,484,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,36
485,485,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,67
486,486,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,119
487,487,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,59
488,488,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,116
489,489,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,99
490,490,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,55
491,491,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,119
492,492,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,120
493,493,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,88
494,494,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,75
495,495,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,94
496,496,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Deniz - DApp Architect,112
497,497,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,94
498,498,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Deniz - DApp Architect,57
499,499,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Can - Gas Optimizer,71
500,500,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,119
501,501,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,68
502,502,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Can - Gas Optimizer,54
503,503,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Can - Gas Optimizer,69
504,504,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,31
505,505,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,47
506,506,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Can - Gas Optimizer,72
507,507,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,56
508,508,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Can - Gas Optimizer,47
509,509,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,52
510,510,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Can - Gas Optimizer,60
511,511,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,81
512,512,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,92
513,513,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,95
514,514,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,36
515,515,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,65
516,516,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,108
517,517,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Deniz - DApp Architect,55
518,518,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,84
519,519,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,56
520,520,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Deniz - DApp Architect,33
521,521,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,63
522,522,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,45
523,523,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Can - Gas Optimizer,114
524,524,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Can - Gas Optimizer,37
525,525,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,108
526,526,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Can - Gas Optimizer,46
527,527,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,100
528,528,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,47
529,529,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Öğretmen Zeynep - Practical,72
530,530,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Mentor Fatma - Supportive,50
531,531,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Öğretmen Zeynep - Practical,76
532,532,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Mentor Fatma - Supportive,115
533,533,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Mentor Fatma - Supportive,66
534,534,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,64
535,535,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,113
536,536,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,101
537,537,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,54
538,538,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,41
539,539,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,107
540,540,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,42
541,541,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Can - Gas Optimizer,91
542,542,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,81
543,543,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Can - Gas Optimizer,105
544,544,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,81
545,545,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Can - Gas Optimizer,72
546,546,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,99
547,547,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,68
548,548,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,103
549,549,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,91
550,550,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Can - Gas Optimizer,75
551,551,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Can - Gas Optimizer,47
552,552,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Can - Gas Optimizer,86
553,553,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Öğretmen Zeynep - Practical,48
554,554,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Dr. Ayşe - Beginner Friendly,114
555,555,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Öğretmen Zeynep - Practical,104
556,556,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,67
557,557,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Dr. Ayşe - Beginner Friendly,112
558,558,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Dr. Ayşe - Beginner Friendly,93
559,559,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,53
560,560,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,95
561,561,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,79
562,562,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,44
563,563,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,54
564,564,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,57
565,565,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,113
566,566,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,81
567,567,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,68
568,568,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,98
569,569,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,99
570,570,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,63
571,571,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,53
572,572,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,57
573,573,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,51
574,574,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Prof. Mehmet - Academic,67
575,575,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,52
576,576,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,65
577,577,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Deniz - DApp Architect,104
578,578,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,97
579,579,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter || msg.sender == buyer, ""Unauthorized"");
        require(!released, ""Already released"");
        require(amount > 0, ""No funds"");

        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Elif - Security Aware,103
580,580,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Deniz - DApp Architect,31
581,581,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        require(stakedBalance[msg.sender] > 0, ""No stake"");

        uint256 timeStaked = block.timestamp - stakingTime[msg.sender];
        uint256 reward = (stakedBalance[msg.sender] * rewardRate * timeStaked) / (365 days * 100);

        uint256 total = stakedBalance[msg.sender] + reward;
        stakedBalance[msg.sender] = 0;

        payable(msg.sender).transfer(total);
        emit Unstaked(msg.sender, total);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Elif - Security Aware,40
582,582,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(block.timestamp < endTime, ""Auction ended"");
        require(msg.value > highestBid, ""Bid too low"");
        require(!ended, ""Auction finalized"");

        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}

        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Elif - Security Aware,61
583,583,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,83
584,584,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,60
585,585,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,81
586,586,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Prof. Mehmet - Academic,87
587,587,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,90
588,588,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,31
589,589,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Öğretmen Zeynep - Practical,53
590,590,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Dr. Ayşe - Beginner Friendly,64
591,591,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Dr. Ayşe - Beginner Friendly,75
592,592,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,59
593,593,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Dr. Ayşe - Beginner Friendly,58
594,594,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,103
595,595,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Deniz - DApp Architect,77
596,596,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,36
597,597,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,50
598,598,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,36
599,599,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Deniz - DApp Architect,48
600,600,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,53
601,601,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Öğretmen Zeynep - Practical,75
602,602,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Öğretmen Zeynep - Practical,97
603,603,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Öğretmen Zeynep - Practical,112
604,604,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Dr. Ayşe - Beginner Friendly,36
605,605,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Dr. Ayşe - Beginner Friendly,43
606,606,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Dr. Ayşe - Beginner Friendly,51
607,607,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Öğretmen Zeynep - Practical,118
608,608,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Dr. Ayşe - Beginner Friendly,72
609,609,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Öğretmen Zeynep - Practical,93
610,610,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Dr. Ayşe - Beginner Friendly,112
611,611,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Dr. Ayşe - Beginner Friendly,35
612,612,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,116
613,613,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,112
614,614,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,52
615,615,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,88
616,616,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Prof. Mehmet - Academic,119
617,617,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,77
618,618,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,52
619,619,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,108
620,620,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,42
621,621,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,118
622,622,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Can - Gas Optimizer,110
623,623,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Can - Gas Optimizer,111
624,624,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Can - Gas Optimizer,74
625,625,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,61
626,626,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,66
627,627,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,66
628,628,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,102
629,629,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,101
630,630,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,84
631,631,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Can - Gas Optimizer,60
632,632,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,40
633,633,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,47
634,634,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,119
635,635,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Can - Gas Optimizer,108
636,636,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Can - Gas Optimizer,44
637,637,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Öğretmen Zeynep - Practical,110
638,638,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Öğretmen Zeynep - Practical,64
639,639,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Mentor Fatma - Supportive,120
640,640,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Mentor Fatma - Supportive,93
641,641,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Öğretmen Zeynep - Practical,46
642,642,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Mentor Fatma - Supportive,61
643,643,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Deniz - DApp Architect,113
644,644,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,82
645,645,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Deniz - DApp Architect,74
646,646,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,98
647,647,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,42
648,648,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,56
649,649,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,119
650,650,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,90
651,651,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,76
652,652,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Prof. Mehmet - Academic,109
653,653,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,35
654,654,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,106
655,655,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Dr. Ayşe - Beginner Friendly,56
656,656,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Dr. Ayşe - Beginner Friendly,57
657,657,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Öğretmen Zeynep - Practical,92
658,658,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,48
659,659,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Öğretmen Zeynep - Practical,79
660,660,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Dr. Ayşe - Beginner Friendly,33
661,661,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,64
662,662,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,46
663,663,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,80
664,664,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,80
665,665,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,94
666,666,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,43
667,667,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,92
668,668,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,100
669,669,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,38
670,670,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Can - Gas Optimizer,83
671,671,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Can - Gas Optimizer,48
672,672,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Can - Gas Optimizer,105
673,673,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,113
674,674,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,95
675,675,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,96
676,676,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Prof. Mehmet - Academic,48
677,677,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,50
678,678,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,56
679,679,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Can - Gas Optimizer,60
680,680,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Can - Gas Optimizer,46
681,681,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,68
682,682,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Can - Gas Optimizer,71
683,683,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,49
684,684,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,40
685,685,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Dr. Ayşe - Beginner Friendly,42
686,686,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Öğretmen Zeynep - Practical,36
687,687,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Öğretmen Zeynep - Practical,68
688,688,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Dr. Ayşe - Beginner Friendly,81
689,689,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Öğretmen Zeynep - Practical,70
690,690,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Dr. Ayşe - Beginner Friendly,82
691,691,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Öğretmen Zeynep - Practical,68
692,692,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Öğretmen Zeynep - Practical,88
693,693,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Dr. Ayşe - Beginner Friendly,56
694,694,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,81
695,695,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Dr. Ayşe - Beginner Friendly,41
696,696,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Dr. Ayşe - Beginner Friendly,67
697,697,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,107
698,698,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,76
699,699,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,90
700,700,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Prof. Mehmet - Academic,64
701,701,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,33
702,702,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,101
703,703,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Can - Gas Optimizer,40
704,704,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,71
705,705,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Can - Gas Optimizer,31
706,706,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,50
707,707,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,42
708,708,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Can - Gas Optimizer,77
709,709,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Deniz - DApp Architect,37
710,710,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(_proposalId < proposals.length, ""Invalid proposal"");
        require(!hasVoted[msg.sender], ""Already voted"");
        require(!proposals[_proposalId].executed, ""Proposal executed"");

        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;

        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Elif - Security Aware,66
711,711,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Deniz - DApp Architect,63
712,712,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Deniz - DApp Architect,61
713,713,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        require(stakedBalance[msg.sender] > 0, ""No stake"");

        uint256 timeStaked = block.timestamp - stakingTime[msg.sender];
        uint256 reward = (stakedBalance[msg.sender] * rewardRate * timeStaked) / (365 days * 100);

        uint256 total = stakedBalance[msg.sender] + reward;
        stakedBalance[msg.sender] = 0;

        payable(msg.sender).transfer(total);
        emit Unstaked(msg.sender, total);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Elif - Security Aware,36
714,714,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(block.timestamp < endTime, ""Auction ended"");
        require(msg.value > highestBid, ""Bid too low"");
        require(!ended, ""Auction finalized"");

        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}

        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Elif - Security Aware,119
715,715,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,96
716,716,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,77
717,717,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,66
718,718,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,87
719,719,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,90
720,720,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,35
721,721,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Mentor Fatma - Supportive,47
722,722,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Mentor Fatma - Supportive,45
723,723,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,46
724,724,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,56
725,725,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,41
726,726,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Mentor Fatma - Supportive,41
727,727,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,83
728,728,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,107
729,729,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,115
730,730,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,70
731,731,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,80
732,732,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,43
733,733,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid address"");
        require(_value > 0, ""Amount must be positive"");
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Elif - Security Aware,116
734,734,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,75
735,735,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Deniz - DApp Architect,69
736,736,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Deniz - DApp Architect,47
737,737,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        require(stakedBalance[msg.sender] > 0, ""No stake"");

        uint256 timeStaked = block.timestamp - stakingTime[msg.sender];
        uint256 reward = (stakedBalance[msg.sender] * rewardRate * timeStaked) / (365 days * 100);

        uint256 total = stakedBalance[msg.sender] + reward;
        stakedBalance[msg.sender] = 0;

        payable(msg.sender).transfer(total);
        emit Unstaked(msg.sender, total);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Elif - Security Aware,103
738,738,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(block.timestamp < endTime, ""Auction ended"");
        require(msg.value > highestBid, ""Bid too low"");
        require(!ended, ""Auction finalized"");

        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}

        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Elif - Security Aware,59
739,739,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Can - Gas Optimizer,109
740,740,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,113
741,741,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Can - Gas Optimizer,120
742,742,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,117
743,743,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Can - Gas Optimizer,70
744,744,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,68
745,745,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ali - Facilitator,69
746,746,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,63
747,747,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,99
748,748,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,83
749,749,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Prof. Mehmet - Academic,92
750,750,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,95
751,751,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Deniz - DApp Architect,51
752,752,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,93
753,753,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,60
754,754,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,63
755,755,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Deniz - DApp Architect,107
756,756,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,118
757,757,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,111
758,758,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,59
759,759,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,43
760,760,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,61
761,761,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,87
762,762,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,32
763,763,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Öğretmen Zeynep - Practical,82
764,764,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Dr. Ayşe - Beginner Friendly,36
765,765,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Öğretmen Zeynep - Practical,87
766,766,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,105
767,767,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Dr. Ayşe - Beginner Friendly,112
768,768,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Dr. Ayşe - Beginner Friendly,40
769,769,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,51
770,770,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,88
771,771,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Deniz - DApp Architect,116
772,772,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Deniz - DApp Architect,44
773,773,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,43
774,774,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,82
775,775,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Dr. Ayşe - Beginner Friendly,75
776,776,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Öğretmen Zeynep - Practical,35
777,777,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Dr. Ayşe - Beginner Friendly,68
778,778,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Dr. Ayşe - Beginner Friendly,108
779,779,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Öğretmen Zeynep - Practical,96
780,780,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,31
781,781,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Can - Gas Optimizer,74
782,782,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Can - Gas Optimizer,39
783,783,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,57
784,784,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,32
785,785,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Can - Gas Optimizer,40
786,786,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,119
787,787,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Öğretmen Zeynep - Practical,36
788,788,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Öğretmen Zeynep - Practical,94
789,789,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Dr. Ayşe - Beginner Friendly,81
790,790,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,73
791,791,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Dr. Ayşe - Beginner Friendly,97
792,792,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Dr. Ayşe - Beginner Friendly,64
793,793,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Dr. Ayşe - Beginner Friendly,90
794,794,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Öğretmen Zeynep - Practical,110
795,795,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Öğretmen Zeynep - Practical,63
796,796,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Dr. Ayşe - Beginner Friendly,99
797,797,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Dr. Ayşe - Beginner Friendly,68
798,798,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,54
799,799,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,74
800,800,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Can - Gas Optimizer,87
801,801,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Can - Gas Optimizer,113
802,802,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,73
803,803,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Can - Gas Optimizer,56
804,804,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,48
805,805,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,106
806,806,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Prof. Mehmet - Academic,46
807,807,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Ali - Facilitator,50
808,808,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Prof. Mehmet - Academic,32
809,809,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,117
810,810,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ali - Facilitator,64
811,811,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,89
812,812,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,68
813,813,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,36
814,814,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Deniz - DApp Architect,48
815,815,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Deniz - DApp Architect,61
816,816,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,68
817,817,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,61
818,818,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Can - Gas Optimizer,76
819,819,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,118
820,820,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,31
821,821,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Can - Gas Optimizer,42
822,822,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Can - Gas Optimizer,78
823,823,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,83
824,824,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Can - Gas Optimizer,57
825,825,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Can - Gas Optimizer,73
826,826,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,50
827,827,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Can - Gas Optimizer,34
828,828,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,111
829,829,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Dr. Ayşe - Beginner Friendly,45
830,830,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Öğretmen Zeynep - Practical,120
831,831,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Dr. Ayşe - Beginner Friendly,90
832,832,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Dr. Ayşe - Beginner Friendly,87
833,833,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Öğretmen Zeynep - Practical,101
834,834,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,36
835,835,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Öğretmen Zeynep - Practical,57
836,836,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Öğretmen Zeynep - Practical,30
837,837,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Mentor Fatma - Supportive,60
838,838,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,62
839,839,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Mentor Fatma - Supportive,70
840,840,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Mentor Fatma - Supportive,108
841,841,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid address"");
        require(_value > 0, ""Amount must be positive"");
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Elif - Security Aware,71
842,842,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(_proposalId < proposals.length, ""Invalid proposal"");
        require(!hasVoted[msg.sender], ""Already voted"");
        require(!proposals[_proposalId].executed, ""Proposal executed"");

        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;

        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Elif - Security Aware,57
843,843,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter || msg.sender == buyer, ""Unauthorized"");
        require(!released, ""Already released"");
        require(amount > 0, ""No funds"");

        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Elif - Security Aware,91
844,844,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Deniz - DApp Architect,95
845,845,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Deniz - DApp Architect,108
846,846,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Deniz - DApp Architect,60
847,847,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Öğretmen Zeynep - Practical,67
848,848,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Dr. Ayşe - Beginner Friendly,77
849,849,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Dr. Ayşe - Beginner Friendly,89
850,850,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,106
851,851,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Öğretmen Zeynep - Practical,89
852,852,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Dr. Ayşe - Beginner Friendly,111
853,853,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Can - Gas Optimizer,104
854,854,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,94
855,855,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,92
856,856,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Can - Gas Optimizer,66
857,857,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,76
858,858,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Can - Gas Optimizer,77
859,859,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid address"");
        require(_value > 0, ""Amount must be positive"");
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Elif - Security Aware,85
860,860,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(_proposalId < proposals.length, ""Invalid proposal"");
        require(!hasVoted[msg.sender], ""Already voted"");
        require(!proposals[_proposalId].executed, ""Proposal executed"");

        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;

        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Elif - Security Aware,106
861,861,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Deniz - DApp Architect,51
862,862,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(_to != address(0), ""Invalid address"");
        require(_value > 0, ""Amount must be positive"");
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Elif - Security Aware,73
863,863,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Deniz - DApp Architect,96
864,864,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Deniz - DApp Architect,48
865,865,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Prof. Mehmet - Academic,38
866,866,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Ali - Facilitator,90
867,867,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Prof. Mehmet - Academic,54
868,868,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Ali - Facilitator,95
869,869,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ali - Facilitator,95
870,870,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Prof. Mehmet - Academic,108
871,871,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Deniz - DApp Architect,47
872,872,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Deniz - DApp Architect,100
873,873,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Deniz - DApp Architect,82
874,874,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,67
875,875,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,40
876,876,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,94
877,877,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Dr. Ayşe - Beginner Friendly,96
878,878,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Öğretmen Zeynep - Practical,59
879,879,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Dr. Ayşe - Beginner Friendly,37
880,880,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Öğretmen Zeynep - Practical,81
881,881,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Dr. Ayşe - Beginner Friendly,47
882,882,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,120
883,883,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Ahmet - Smart Contract Beginner,82
884,884,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Can - Gas Optimizer,41
885,885,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Can - Gas Optimizer,42
886,886,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Can - Gas Optimizer,90
887,887,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Ahmet - Smart Contract Beginner,32
888,888,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Ahmet - Smart Contract Beginner,57
889,889,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedToken
 * @dev Gas-optimized ERC20 token with security features
 */
contract AdvancedToken {
    string public constant name = ""Advanced Token"";
    string public constant symbol = ""ADV"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        
    }

    
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Burak - Blockchain Specialist,63
890,890,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/**
 * @title AdvancedVoting
 * @dev Weighted voting with delegation
 */
contract AdvancedVoting is Ownable, ReentrancyGuard {
    struct Voter {
        uint256 weight;
        bool voted;
        address delegate;
        uint256 vote;
    }

    struct Proposal {
        bytes32 name;
        uint256 voteCount;
        uint256 deadline;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function delegate(address to) external nonReentrant {
        
    }

    function vote(uint256 proposal) external {
        
    }

    
}",solidity,Create a Voting System - Basit oylama mekanizması,Burak - Blockchain Specialist,68
891,891,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/**
 * @title SecureEscrow
 * @dev Multi-signature escrow with dispute resolution
 */
contract SecureEscrow is ReentrancyGuard, Pausable {
    enum State { AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE, DISPUTED }

    struct Transaction {
        address payable buyer;
        address payable seller;
        uint256 amount;
        State state;
        uint256 deadline;
    }

    

    modifier onlyBuyer(uint256 txId) {
        require(msg.sender == transactions[txId].buyer, ""Not buyer"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function createTransaction(address payable _seller) external payable nonReentrant {
        
    }

    function confirmDelivery(uint256 txId) external onlyBuyer(txId) nonReentrant {
        
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Burak - Blockchain Specialist,73
892,892,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedNFT
 * @dev Full ERC721 with metadata and royalties
 */
contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    uint96 public royaltyPercentage = 250; // 2.5%

    mapping(uint256 => address) private _royaltyReceivers;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function safeMint(address to, string memory uri) public onlyOwner {
        
    }

    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        
    }

    
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Burak - Blockchain Specialist,49
893,893,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedStaking
 * @dev Time-weighted rewards with compound interest
 */
contract AdvancedStaking is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    struct StakeInfo {
        uint256 amount;
        uint256 timestamp;
        uint256 rewardDebt;
        uint256 accumulatedRewards;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function stake(uint256 amount) external nonReentrant {
        
    }

    function calculateRewards(address user) public view returns (uint256) {
        
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Burak - Blockchain Specialist,38
894,894,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title AdvancedAuction
 * @dev English auction with auto-extension and reserve price
 */
contract AdvancedAuction is ReentrancyGuard, Ownable {
    enum AuctionState { ACTIVE, ENDED, CANCELLED }

    struct Auction {
        address payable seller;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 bidIncrement;
        uint256 highestBid;
        address highestBidder;
        AuctionState state;
    }

    

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        
    }

    function finalizeAuction(uint256 auctionId) external nonReentrant {
        
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Burak - Blockchain Specialist,40
895,895,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @dev Basit bir ERC20-benzeri token kontratı
 * @notice Bu kontrat eğitim amaçlıdır
 */
contract SimpleToken {
    // Token bilgileri
    string public name = ""Simple Token"";
    string public symbol = ""SMP"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Bakiye kayıtları
    mapping(address => uint256) public balanceOf;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token transferi yapar
     * @param _to Alıcı adresi
     * @param _value Transfer miktarı
     * @return success Transfer başarılı mı?
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Token Transfer Contract - ERC20 benzeri basit token,Dr. Ayşe - Beginner Friendly,41
896,896,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleVoting
 * @dev Basit bir oylama sistemi
 */
contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool executed;
    }

    address public owner;
    Proposal[] public proposals;
    mapping(address => bool) public hasVoted;

    event ProposalCreated(uint256 proposalId, string description);
    event Voted(address voter, uint256 proposalId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni teklif oluşturur
     */
    function createProposal(string memory _description) public {
        require(msg.sender == owner, ""Only owner"");
        proposals.push(Proposal({{
            description: _description,
            voteCount: 0,
            executed: false
        }}));
        emit ProposalCreated(proposals.length - 1, _description);
    }

    /**
     * @dev Teklife oy verir
     */
    function vote(uint256 _proposalId) public {
        require(!hasVoted[msg.sender]);
        hasVoted[msg.sender] = true;
        proposals[_proposalId].voteCount++;
        emit Voted(msg.sender, _proposalId);
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a Voting System - Basit oylama mekanizması,Dr. Ayşe - Beginner Friendly,40
897,897,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleEscrow
 * @dev İki taraf arasında güvenli ödeme
 */
contract SimpleEscrow {
    address public buyer;
    address public seller;
    address public arbiter;
    uint256 public amount;
    bool public released;

    event FundsDeposited(address buyer, uint256 amount);
    event FundsReleased(address seller, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Fon yatırma
     */
    function deposit() public payable {
        require(msg.sender == buyer, ""Only buyer"");
        require(msg.value > 0, ""Amount required"");
        amount = msg.value;
        emit FundsDeposited(buyer, amount);
    }

    /**
     * @dev Fon serbest bırakma
     */
    function releaseFunds() public {
        require(msg.sender == arbiter);
        released = true;
        payable(seller).transfer(amount);
        emit FundsReleased(seller, amount);
    }

    
}",solidity,Create a Escrow Contract - Güvenli ödeme sistemi,Öğretmen Zeynep - Practical,92
898,898,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleNFT
 * @dev Basit NFT mint etme
 */
contract SimpleNFT {
    string public name = ""Simple NFT"";
    string public symbol = ""SNFT"";
    uint256 public tokenCounter;

    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public balanceOf;

    event Minted(address to, uint256 tokenId);
    event Transfer(address from, address to, uint256 tokenId);

    /**
     * @dev Constructor - Kontratı başlatır
     */
    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Yeni NFT mint eder
     */
    function mint() public {
        uint256 newTokenId = tokenCounter;
        tokenCounter++;
        tokenOwner[newTokenId] = msg.sender;
        balanceOf[msg.sender]++;
        emit Minted(msg.sender, newTokenId);
    }

    /**
     * @dev NFT transferi
     */
    function transfer(address _to, uint256 _tokenId) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    /**
     * @dev Bakiye sorgulama
     * @param _owner Sorgulanacak adres
     * @return Bakiye miktarı
     */
    function getBalance(address _owner) public view returns (uint256) {
        return balanceOf[_owner];
    }
}",solidity,Create a NFT Minting - ERC721 benzeri NFT,Dr. Ayşe - Beginner Friendly,32
899,899,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleStaking
 * @dev Basit token staking
 */
contract SimpleStaking {
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public stakingTime;
    uint256 public rewardRate = 10; // 10% yıllık

    event Staked(address user, uint256 amount);
    event Unstaked(address user, uint256 amount);
    event RewardClaimed(address user, uint256 reward);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Token stake et
     */
    function stake() public payable {
        require(msg.value > 0, ""Amount required"");
        stakedBalance[msg.sender] += msg.value;
        stakingTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, msg.value);
    }

    /**
     * @dev Stake çöz ve ödül al
     */
    function unstake() public {
        uint256 amount = stakedBalance[msg.sender];
        stakedBalance[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Unstaked(msg.sender, amount);
    }

    
}",solidity,Create a Staking Contract - Token stake etme,Öğretmen Zeynep - Practical,51
900,900,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleAuction
 * @dev Basit açık artırma
 */
contract SimpleAuction {
    address public seller;
    uint256 public highestBid;
    address public highestBidder;
    uint256 public endTime;
    bool public ended;

    mapping(address => uint256) public pendingReturns;

    event NewBid(address bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;
    }

    /**
     * @dev Teklif ver
     */
    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {{
            pendingReturns[highestBidder] += highestBid;
        }}
        highestBid = msg.value;
        highestBidder = msg.sender;
        emit NewBid(msg.sender, msg.value);
    }

    /**
     * @dev Açık artırmayı sonlandır
     */
    function endAuction() public {
        require(block.timestamp >= endTime, ""Too early"");
        require(!ended, ""Already ended"");
        ended = true;
        payable(seller).transfer(highestBid);
        emit AuctionEnded(highestBidder, highestBid);
    }

    
}",solidity,Create a Auction System - Açık artırma sistemi,Öğretmen Zeynep - Practical,41
